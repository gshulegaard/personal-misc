# Tutorial Notes:

## --- BASIC CRUD ---

# --- Index a JSON document ---

#     ---- Index Name
#     |
#     |       ----- Type Name
#     |       |
#     |       |    ---- Doc ID
#     |       |    |
#     V       V    V
PUT /library/books/1
{
    "title": "A fly on the wall",
    "name": {
        "first": "Drosophila",
        "last": "Melanogaster"
    },
    "publish_date": "2015-06-21T23:39:49-0400",
    "price": 19.95
}

{
    "_index": "library",
    "_type": "books",
    "_id": "1",
    "_version": 1,
    "created": true
}

# --- Retrieve the same document via ID ---

GET /library/books/1

{
    "_index": "library",  # \
    "_type": "books",     #  \
    "_id": "1",           #   | Meta information
    "_version": 1,        #  /
    "found": true,        # / (Action/elastic descriptor)
    "_source": {
        "title": "A fly on the wall",
        "name": {
            "first": "Drosophila",
            "last": "Melanogaster"
        },
        "publish_date": "2015-06-21T23:39:49-0400",
        "price": 19.95
    }
}

# --- Bad GET query ---

GET /library/books/does_not_exist

{
    "_index": "library",
    "_type": "books",
    "_id": "does_not_exist",
    "found": false,
}

# --- ID's are optional ---

POST /library/books/
{
    "title": "Adventures of Strange-Foot Smooth",
    "name": {
        "first": "Xenopus",
        "last": "laevis"
    },
    "publish_date": "2015-05-01T06:11:26-0400",
    "price": 5.99
}

{
    "_index": "library",
    "_type": "books",
    "_id": "AU4mY5X76XBH0GqmhW-Z",  # Elastic will auto-create an ID hash for you.
    "_version": 1,
    "created": true
}

# --- To retrieve we NEED the ID that was autogenerated ---

GET /library/books/AU4mY5X76XBH0GqmhW-Z

{
    "_index": "library",
    "_type": "books",
    "_id": "AU4mY5X76XBH0GqmhW-Z",
    "_version": 1,
    "found": true,
    "_source": {
        "title": "Adventures of Strange-Foot Smooth",
        "name": {
            "first": "Xenopus",
            "last": "laevis"
        },
        "publish_date": "2015-05-01T06:11:26-0400",
        "price": 5.99
    }
}

# --- To update a doc, we can overwrite it ---

PUT /library/books/1
{
    "title": "A fly on the wall Part 2",
    "name": {
        "first": "Drosophila",
        "last": "Melanogaster"
    },
    "publish_date": "2015-06-21T23:39:49-0400",
    "price": 29.95
}

{
    "_index": "library",
    "_type": "books",
    "_id": "1",
    "_version": 2,    # Note that that version incremented.
    "created": false  # Also created is false now.
}

GET /library/books/1

{
    "_index": "library",
    "_type": "books",
    "_id": "1",
    "_version": 2,
    "found": true,
    "_source": {
        "title": "A fly on the wall Part 2",
        "name": {
            "first": "Drosophila",
            "last": "Melanogaster"
        },
        "publish_date": "2015-06-21T23:39:49-0400",
        "price": 29.95
    }
}

# Caveat of overwriting is that it will overwrite the entire stored document.  If you forget a field or don't have
# access to *all* of hte previous fields, then the new overwritten version will be missing the field.

PUT /library/books/1
{
    "title": "A fly on the wall Part 2",
    "name": {
        "first": "Drosophila",
        "last": "Melanogaster"
    },
    "publish_date": "2015-06-21T23:39:49-0400"
    # Note "price" is gone here.
}

GET /library/books/1

{
    "_index": "library",
    "_type": "books",
    "_id": "1",
    "_version": 3,
    "found": true,
    "_source": {
        "title": "A fly on the wall Part 2",
        "name": {
            "first": "Drosophila",
            "last": "Melanogaster"
        },
        "publish_date": "2015-06-21T23:39:49-0400"
    }
}

# --- For partial updates you have to use _update API ---

POST /library/books/1/_update
{
    "doc": {  # This doc parameter contains the fields we want to upsert into "_source"
        "price": 10
    }
}

{
    "_index": "library",
    "_type": "books",
    "_id": "1",
    "_version": 4,  # Note that that version incremented.
}

GET /library/books/1

{
    "_index": "library",
    "_type": "books",
    "_id": "1",
    "_version": 4,
    "found": true,
    "_source": {
        "title": "A fly on the wall Part 2",
        "name": {
            "first": "Drosophila",
            "last": "Melanogaster"
        },
        "publish_date": "2015-06-21T23:39:49-0400",
        "price": 10
    }
}

# Upsert is an append.  New fields will be appended to the "_source" JSON.

# --- There is a delete ---

DELETE /library/books/1

{
    "found": true,
    "_index": "library",
    "_type": "books",
    "_id": "1",
    "_version": 5,  # Note that that version incremented.
}

# --- We can even delete an entire index ---

DELETE /library/

{
    "acknowledged": true
}

# Advanced CRUD: https://www.elastic.co/guide/en/elasticsearch/guide/current/data-in-data-out.html

## -- SEARCH ---

# --- Bulk indexing and search ---

POST /library/books/_bulk
#  --- Action
#  |
#  |           ---  Action Info
#  |           |
#  V           V
{ "index": { "_id": 1 }}\n
# JSON document for action on line above.
{ "title": "The quick brown fox", "price": 5 }\n  <-- Elasticsearch needs new lines for parsing.  NO PRETTY PRINTING.
{ "index": { "_id": 2 }}
{ "title": "The quick brown fox jumps over the lazy dog", "price": 15 }
{ "index": { "_id": 3 }}
{ "title": "The quick brown fox jumps over the quick dog", "price": 8 }
{ "index": { "_id": 4 }}
{ "title": "Brown fox brown dog", "price": 2 }
{ "index": { "_id": 5 }}
{ "title": "Lazy dog", "price": 9 }

# More info: https://www.elastic.co/guide/en/elasticsearch/guide/current/bulk.html

# --- Basic search (find all) ---

GET /library/books/_search
# No request body here...

{
    "took": 20,
    "timed_out": false,
    "_shards": {
        "total": 5,
        "successful": 5,
        "failed": 0
    },
    "hits": {  # Docs returned
        "total": 5,
        "max_score": 1,
        "hits": [
            {
                "_index": "library",
                "_type": "books",
                "_id": "4",  # Note not sorted by _id, but by _score.
                "_score": 1,  # Relevance of hit to query.  1 because no criteria.
                "_source": {
                    "title": "Brown fox brown dog",
                    "price": 2
                }
            },
            ...
        ]
    }
}

# --- Search with query match ---

GET /library/books/_search
{
    "query": {
        "match": {
            "title": "fox"  # e.g. "FIELD": "TEXT"
        }
    }
}

{
    "took": 18,
    "timed_out": false,
    "_shards": {
        "total": 5,
        "successful": 5,
        "failed": 0
    },
    "hits": {
        "total": 4,  # Note one of the entries was left out
        "max_score": 0.15342641,
        "hits": [
            {
                "_index": "library",
                "_type": "books",
                "_id": "4",
                "_score": 0.15342641,
                "_source": {
                    "title": "Brown fox brown dog",
                    "price": 2
                }
            },
            {
                "_index": "library",
                "_type": "books",
                "_id": "1",
                "_score": 0.15342641,
                "_source": {
                    "title": "The quick brown fox",
                    "price": 5
                }
            },
            {
                "_index": "library",
                "_type": "books",
                "_id": "2",
                "_score": 0.095891505,
                "_source": {
                    "title": "The quick brown fox jumps over the lazy dog",
                    "price": 15
                }
            },
            {
                "_index": "library",
                "_type": "books",
                "_id": "3",
                "_score": 0.095891505,
                "_source": {
                    "title": "The quick brown fox jumps over the quick dog",
                    "price": 8
                }
            }
        ]
    }
}

GET /library/books/_search
{
    "query": {
        "match": {
            "title": "quick dog"
        }
    }
}

{
    "took": 5,
    "timed_out": false,
    "_shards": {
        "total": 5,
        "successful": 5,
        "failed": 0
    },
    "hits": {
        "total": 5,
        "max_score": 0.16369703,
        "hits": [
            {
                "_index": "library",
                "_type": "books",
                "_id": "3",
                "_score": 0.16369703,
                "_source": {
                    "title": "The quick brown fox jumps over the quick dog",
                    "price": 8
                }
            },
            {
                "_index": "library",
                "_type": "books",
                "_id": "2",
                "_score": 0.13561106,
                "_source": {
                    "title": "The quick brown fox jumps over the lazy dog",
                    "price": 15
                }
            },
            ...
        ]
    }
}

# --- Search with match_phrase ---

GET /library/books/_search
{
    "query": {
        "match_phrase": {
            "title": "quick dog"  # e.g. "FIELD": "PHRASE"
        }
    }
}

# Only returns documents that have a complete instance of the phrase "quick dog"
{
    "took": 36,
    "timed_out": false,
    "_shards": {
        "total": 5,
        "successful": 5,
        "failed": 0
    },
    "hits": {
        "total": 1,
        "max_score": 0.19178301,  # Notice that the max_score does not go to 1 even if there is only 1 match.
        "hits": [
            {
                "_index": "library",
                "_type": "books",
                "_id": "3",
                "_score": 0.19178301,
                "_source": {
                    "title": "The quick brown fox jumps over the quick dog",
                    "price": 8
                }
            }
        ]
    }
}

# There is some complexities to how _score is calculated...
# More info: https://www.elastic.co/guide/en/elasticsearch/guide/current/relevance-intro.html

# --- Search with boolean query ---

GET /library/books/_search
# {
#     "query": {
#         "bool": {
#             "must": [
#                 {}  # Required
#             ],
#             "must_not": [
#                 {}  # Negation
#             ],
#             "should": [
#                 {}  # Optional, better scoring if matching
#             ]
#         }
#     }
# }
{
    "query": {
        "bool": {
            "must": [
                {
                    "match": {
                        "title": "quick"
                    }
                },
                {
                    "match_phrase": {
                        "title": "lazy dog"
                    }
                }
            ]
        }
    }
}

# --- Search with boolean and boosting ---

GET /library/books/_search
{
    "query": {
        "bool": {
            "should": [
                {
                    "match_phrase": {
                        "title": {
                            "query": quick dog",
                            "boost": 5  # 5x (multiple).  Can be fractional (e.g. 0.5)
                        }
                    }
                },
                {
                    "match_phrase": {
                        "title": {
                            "query": "lazy dog"
                        }
                    }
                }
            ]
        }
    }
}

# --- Highlighting ---

GET /library/books/_search
{
    "query": {
        "bool": {
            "should": [
                {
                    "match_phrase": {
                        "title": {
                            "query": "quick dog",
                            "boost": 5  # 5x (multiple).  Can be fractional (e.g. 0.5)
                        }
                    }
                },
                {
                    "match_phrase": {
                        "title": {
                            "query": "lazy dog"
                        }
                    }
                }
            ]
        }
    }
    "highlight": {
        "fields": {
            "title": {}
        }
    }
}

# --- Short notes on filtering ---

# Filtering is basically a way to do inclusion or exclusion (match or does not match).

# Filters are useful if you don't need scoring.  Filtering is often faster than querying.  (Just doing the structured
# search and don't need score)

# Filters and queries can be combined.

# More info: https://www.elastic.co/guide/en/elasticsearch/guide/current/structured-search.html

# Aside: Filters will probably be how we limit our timeseries stuff.  Similar to a WHERE clause in SQL.

# --- Short notes on analysis ---

# Analysis = tokenization + token filters

# Different analysis can result in VERY different search behavior.

# More info: https://www.elastic.co/guide/en/elasticsearch/guide/current/_controlling_analysis.html

# --- Short notes on mappings ---

GET /library/_mapping

{
    "library": {
        "mappings": {
            "books": {  # books type
                "properties": {
                    "price": {  # price field
                        "type": "long"  # data type
                    },
                    "title": {  $ title field
                        "type": "string"  # data type
                    }
                }
            }
        }
    }
}

# ES mappings are similar to PSQL schemas

# You can really tweak behaviors using mappings.  Field-by-field analyzers for example.

# Once a type has been indexed, it is effectively immutable.  ES will refuse to let you change it.  This is for a number
# of reasons (e.g. potentially costly for conversion/re-creating index, backwards compatibility, etc.).

# Mappings impact how the the index is constructed, NOT how the source is stored.  This means that if you have a long
# field, the index will truncate a double into a long.  Which means your index effectively lost precision even though
# the underlying _source data is still accurate.
